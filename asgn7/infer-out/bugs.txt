Found 16 issues

trie.c:11: error: NULL_DEREFERENCE
  pointer `trie` last assigned on line 9 could be null and is dereferenced at line 11, column 5.
  9.     TrieNode *trie = (TrieNode *)calloc(1, sizeof(TrieNode));
  10.     for (int i = 0; i < ALPHABET; i++) {
  11. >     trie->children[i] = NULL;
  12.     }
  13.     trie->code = code;

word.c:14: error: NULL_DEREFERENCE
  pointer `w->syms` last assigned on line 12 could be null and is dereferenced by call to `memcpy()` at line 14, column 3.
  12.     w->syms =(uint8_t *)calloc(len, sizeof(uint8_t));  
  13.     }
  14. >   memcpy(w->syms, syms, len);
  15.     
  16.     //w->syms = *syms;

word.c:12: error: NULL_DEREFERENCE
  pointer `w` last assigned on line 10 could be null and is dereferenced at line 12, column 3.
  10.     Word *w = (Word *)calloc(1, sizeof(Word));
  11.     if(len != 0){
  12. >   w->syms =(uint8_t *)calloc(len, sizeof(uint8_t));  
  13.     }
  14.     memcpy(w->syms, syms, len);

word.c:14: error: NULL_DEREFERENCE
  pointer `w` last assigned on line 10 could be null and is dereferenced at line 14, column 10.
  12.     w->syms =(uint8_t *)calloc(len, sizeof(uint8_t));  
  13.     }
  14. >   memcpy(w->syms, syms, len);
  15.     
  16.     //w->syms = *syms;

word.c:26: error: NULL_DEREFERENCE
  pointer `appended_word->syms` last assigned on line 24 could be null and is dereferenced at line 26, column 3.
  24.     appended_word->syms = (uint8_t *)realloc(appended_word->syms, sizeof(uint8_t) * (appended_word->len + 1));
  25.     appended_word->len = appended_word->len + 1;
  26. >   appended_word->syms[w->len] = sym;
  27.     return appended_word;
  28.   }

trie.c:30: error: DEAD_STORE
  The value written to &root (type TrieNode*) is never used.
  28.     trie_delete(root);
  29.     free(root);
  30. >   root = trie_create();
  31.     return;
  32.   }

io.c:29: error: DEAD_STORE
  The value written to &check (type int) is never used.
  27.   
  28.   void read_header(int infile, FileHeader *header) {
  29. >   int check = read(infile, header, sizeof(FileHeader));
  30.     return;
  31.   }

encode.c:66: error: MEMORY_LEAK
  memory dynamically allocated by call to `calloc()` at line 57, column 34 is not reachable after line 66, column 7.
  64.       if(count == buffer_size){
  65.         buffer_size = buffer_size * 2;
  66. >       file_out = (uint8_t *)realloc(file_out, buffer_size);
  67.       }
  68.     }

encode.c:61: error: NULL_DEREFERENCE
  pointer `file_out` last assigned on line 57 could be null and is dereferenced by call to `read()` at line 61, column 14.
  59.     int count = 0;
  60.     int j;
  61. >   while((j = read(STDIN_FILENO, file_out, 1)) > 0){
  62.       count++;
  63.       write(temp_file, file_out, 1);

io.c:34: error: DEAD_STORE
  The value written to &check (type int) is never used.
  32.   
  33.   void write_header(int outfile, FileHeader *header) {
  34. >   int check = write(outfile, header, sizeof(FileHeader));
  35.      return;
  36.   }

word.c:38: error: NULL_DEREFERENCE
  pointer `word` last assigned on line 37 could be null and is dereferenced at line 38, column 3.
  36.   WordTable *wt_create(void) {
  37.     WordTable *word = (WordTable *)calloc(UINT16_MAX - 1, sizeof(Word));
  38. >   word[EMPTY_CODE] = word_create(0, 0);
  39.     return word;
  40.   }

word.c:44: error: DEAD_STORE
  The value written to &wt (type Word**) is never used.
  42.   void wt_reset(WordTable *wt) {
  43.     wt_delete(wt);
  44. >   wt = wt_create();
  45.     return;
  46.   }

io.c:63: error: DEAD_STORE
  The value written to &bytess (type int) is never used.
  61.   void buffer_pair(int outfile, uint16_t code, uint8_t sym, uint8_t bitlen) {
  62.     int i;
  63. >   int bytess = (bitlen / 8) + 1;  
  64.     uint16_t temporary;
  65.     if (buff_ind == BUFF_LIMIT) {

io.c:67: error: DEAD_STORE
  The value written to &y (type int) is never used.
  65.     if (buff_ind == BUFF_LIMIT) {
  66.        bytes_out = bytes_out + BUFF_LIMIT;
  67. >     int y = write(outfile, buffer, BUFF_LIMIT);//If the buffer is full write it out.
  68.       buff_index = 0;
  69.       buff_ind = 0;

io.c:99: error: DEAD_STORE
  The value written to &t (type int) is never used.
  97.   
  98.   void flush_pairs(int outfile) {
  99. >   int t = write(outfile, buffer, (buff_ind));
  100.     bytes_out = bytes_out + ((buff_ind));
  101.     return;

io.c:109: error: DEAD_STORE
  The value written to &bytess (type int) is never used.
  107.     uint8_t temp[BUFF_LIMIT];
  108.     uint32_t shift_by = bitlen - 1;
  109. >   int bytess = (bitlen / 8) + 1;
  110.     if (read_ind == 0 || read_ind == BUFF_LIMIT) {
  111.       int d = read(infile, it, BUFF_LIMIT);

Summary of the reports

        DEAD_STORE: 8
  NULL_DEREFERENCE: 7
       MEMORY_LEAK: 1